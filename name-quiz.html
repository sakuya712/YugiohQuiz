<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¼ãƒ‰åå½“ã¦ã‚¯ã‚¤ã‚º</title>
    <link rel="stylesheet" href="style.css"> 
    <style>
        /* ç°¡å˜ãªCSSã‚’è¿½åŠ ã—ã¦é¸æŠè‚¢ã‚’è¦‹ã‚„ã™ãã—ã¦ã„ã¾ã™ */
        #options-area {
            display: grid;
            grid-template-columns: 1fr 1fr; /* 2åˆ—è¡¨ç¤º */
            gap: 10px;
            margin-top: 20px;
        }
        .option-button {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .option-button:hover:not(:disabled) {
            background-color: #e0e0e0;
        }
        .correct { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .incorrect { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        #current-mode { margin-bottom: 10px; font-weight: bold; }
    </style>
</head>
<body>

    <div id="quiz-container">
        <h2>ã“ã®ã‚«ãƒ¼ãƒ‰ã®åå‰ã¯ï¼Ÿ</h2>

        <p id="current-mode"></p>
        
        <img id="card-image" src="" alt="ã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ©ã‚¹ãƒˆ" style="max-width: 100%; height: auto;">
        
        <div id="options-area">
            </div>
        
        <p id="feedback"></p>
        
        <button id="next-button" style="display: none;">æ¬¡ã®å•é¡Œã¸</button>
    </div>

    <script>
        // HTMLã®è¦ç´ ã‚’å–å¾—
        const cardImage = document.getElementById('card-image');
        const optionsArea = document.getElementById('options-area');
        const feedback = document.getElementById('feedback');
        const nextButton = document.getElementById('next-button');

        const NUM_OPTIONS = 6;      // é¸æŠè‚¢ã®ç·æ•° (å›ºå®š)
        const NUM_WRONG_OPTIONS = 5; // ä¸æ­£è§£ã®é¸æŠè‚¢ã®æ•° (å›ºå®š)
        const MIN_SIMILAR = 3;      // similar_ids ã‹ã‚‰é¸ã¶æœ€å°æ•°
        const MAX_SIMILAR = 5;      // similar_ids ã‹ã‚‰é¸ã¶æœ€å¤§æ•°
        
        let allCardData = {}; // ã‚­ãƒ¼ãŒã‚«ãƒ¼ãƒ‰ID(æ–‡å­—åˆ—)ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        let cardIds = [];     
        let currentCorrectName = ""; // æ­£è§£åï¼ˆå¸¸ã« name_jpï¼‰

        /**
         * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°: é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ (Fisher-Yatesã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ )
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        /**
         * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°: æœ€å°å€¤ã‹ã‚‰æœ€å¤§å€¤ã¾ã§ã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ•´æ•°ã‚’ç”Ÿæˆ
         */
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * 1. ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
         */
        async function initializeGame() {
            try {
                const response = await fetch('data/CardMetadata.json');
                if (!response.ok) throw new Error('CardMetadata.jsonã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                
                const cardArray = await response.json(); 
                
                // é…åˆ—ã‚’ card_id (æ–‡å­—åˆ—)ã‚’ã‚­ãƒ¼ã¨ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
                allCardData = cardArray.reduce((map, card) => {
                    map[String(card.card_id)] = card; 
                    return map;
                }, {});
                
                cardIds = Object.keys(allCardData);
                
                if (cardIds.length < NUM_OPTIONS) {
                    feedback.textContent = `ã‚¯ã‚¤ã‚ºã«ã¯æœ€ä½${NUM_OPTIONS}æšã®ã‚«ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™ã€‚`;
                    feedback.className = 'incorrect';
                    return;
                }

                loadNewQuestion();

            } catch (error) {
                console.error(error);
                feedback.textContent = 'ã‚¯ã‚¤ã‚ºã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
                feedback.className = 'incorrect';
            }
        }

        /**
         * 2. æ–°ã—ã„å•é¡Œã‚’èª­ã¿è¾¼ã‚€
         */
        async function loadNewQuestion() {
            // UIã‚’ãƒªã‚»ãƒƒãƒˆ
            feedback.textContent = '';
            feedback.className = '';
            optionsArea.innerHTML = ''; // é¸æŠè‚¢ã‚’ã‚¯ãƒªã‚¢
            nextButton.style.display = 'none';

            // 1. æ­£è§£ã‚«ãƒ¼ãƒ‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
            const correctCardIdKey = cardIds[Math.floor(Math.random() * cardIds.length)]; 
            const correctCardData = allCardData[correctCardIdKey];
            currentCorrectName = correctCardData.name_jp; 

            // ç”»åƒã®è¨­å®š
            const cardId = correctCardData.card_id; 
            const currentFileName = `${cardId}.webp`;
            cardImage.src = `images/${currentFileName}`;
            cardImage.alt = 'ã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ©ã‚¹ãƒˆ';

            // é¸æŠè‚¢ãƒªã‚¹ãƒˆ (æ­£è§£ã‚’å«ã‚€)
            let allOptions = [currentCorrectName];
            let usedNames = new Set([currentCorrectName]); // é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨
            let wrongOptions = []; // ä¸æ­£è§£ã®é¸æŠè‚¢

            // â˜…å¤‰æ›´ç®‡æ‰€: å†…éƒ¨ã§ãƒ¢ãƒ¼ãƒ‰ã‚’æ±ºå®šã™ã‚‹â˜…
            // const selectionMode = Math.random() < 0.5 ? 'similar' : 'random'; 
            const selectionMode = 'similar';


            if (selectionMode === 'similar') {
                // =============== Similarãƒ¢ãƒ¼ãƒ‰ =================

                // â˜…å¤‰æ›´ç‚¹1: similar_ids ã‹ã‚‰é¸ã¶æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š (3, 4, 5)
                const similarIds = correctCardData.similar_ids || [];
                const maxPossibleSimilar = Math.min(similarIds.length, NUM_WRONG_OPTIONS);
                
                // similar_idsã‹ã‚‰é¸ã¶å®Ÿéš›æ•°ã‚’æ±ºå®š (min_similarã‹ã‚‰max_similarã®é–“ã€ã‹ã¤ã€å®Ÿéš›ã«é¸ã¹ã‚‹æœ€å¤§æ•°ã‚’è¶…ãˆãªã„)
                const NUM_SIMILAR_ACTUAL = getRandomInt(MIN_SIMILAR, MAX_SIMILAR);
                const NUM_SIMILAR_TO_PICK = Math.min(NUM_SIMILAR_ACTUAL, maxPossibleSimilar);
                
                // â˜…å¤‰æ›´ç‚¹2: æ®‹ã‚Šã¯ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒ¼ãƒ‰ã‹ã‚‰é¸ã¶ (5 - NUM_SIMILAR_TO_PICK)
                const NUM_RANDOM_TO_PICK = NUM_WRONG_OPTIONS - NUM_SIMILAR_TO_PICK;

                
                // 2-a. similar_ids ã‹ã‚‰ NUM_SIMILAR_TO_PICK å€‹ã®é¸æŠè‚¢ã‚’é¸ã¶
                let similarOptions = [];
                const shuffledSimilarIds = shuffleArray([...similarIds]);
                
                for (const sId of shuffledSimilarIds) {
                    const similarData = allCardData[String(sId)]; 
                    
                    if (similarData) {
                        const similarName = similarData.name_jp;
                        if (!usedNames.has(similarName)) {
                            similarOptions.push(similarName);
                            usedNames.add(similarName);
                        }
                    }
                    if (similarOptions.length >= NUM_SIMILAR_TO_PICK) break;
                }
                
                // 2-b. æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã« NUM_RANDOM_TO_PICK å€‹ã®é¸æŠè‚¢ã‚’é¸ã¶
                let randomOptions = [];
                let remainingIds = cardIds.filter(id => {
                    const idNum = parseInt(id, 10);
                    // è‡ªèº«ã¨similar_idsã«å«ã¾ã‚Œã‚‹IDã®ä¸¡æ–¹ã¨ä¸€è‡´ã—ãªã„ID
                    return id !== correctCardIdKey && !similarIds.includes(idNum);
                });

                shuffleArray(remainingIds);

                for (const rId of remainingIds) {
                    const randomData = allCardData[rId];
                    if (randomData) {
                        const randomName = randomData.name_jp;
                        if (!usedNames.has(randomName)) {
                            randomOptions.push(randomName);
                            usedNames.add(randomName);
                        }
                    }
                    if (randomOptions.length >= NUM_RANDOM_TO_PICK) break;
                }
                
                wrongOptions = [...similarOptions, ...randomOptions];
                
            } else { 
                // =============== Randomãƒ¢ãƒ¼ãƒ‰ (Random 5) =================

                let randomOptions = [];
                
                // è‡ªèº«ã‚’é™¤å¤–ã—ãŸå…¨ã‚«ãƒ¼ãƒ‰ID
                let remainingIds = cardIds.filter(id => id !== correctCardIdKey); 
                shuffleArray(remainingIds);

                for (const rId of remainingIds) {
                    const randomData = allCardData[rId];
                    if (randomData) {
                        const randomName = randomData.name_jp;
                        if (!usedNames.has(randomName)) {
                            randomOptions.push(randomName);
                            usedNames.add(randomName);
                        }
                    }
                    if (randomOptions.length >= NUM_WRONG_OPTIONS) break;
                }
                
                wrongOptions = randomOptions;
            }

            // 4. å…¨ã¦ã®é¸æŠè‚¢ã‚’çµåˆ
            allOptions = [...allOptions, ...wrongOptions];
            
            // é¸æŠè‚¢ã®æ•°ãŒNUM_OPTIONSã«æº€ãŸãªã„å ´åˆã¯ã€åŸ‹ã‚åˆã‚ã›ã‚’ã™ã‚‹ (ä¿é™º)
            let supplementaryOptions = [];
            let shuffledCardIds = shuffleArray([...cardIds]);
            for (const id of shuffledCardIds) {
                if (allOptions.length >= NUM_OPTIONS) break;
                const data = allCardData[id];
                if (data && !usedNames.has(data.name_jp)) {
                    supplementaryOptions.push(data.name_jp);
                    usedNames.add(data.name_jp);
                }
            }
            allOptions = [...allOptions, ...supplementaryOptions];

            // æœ€çµ‚çš„ã«6ã¤ã®é¸æŠè‚¢ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            allOptions = shuffleArray(allOptions.slice(0, NUM_OPTIONS)); 

            // 5. é¸æŠè‚¢ãƒœã‚¿ãƒ³ã®ç”Ÿæˆ
            allOptions.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-button';
                button.textContent = option;
                button.setAttribute('data-name', option);
                button.addEventListener('click', handleOptionClick);
                optionsArea.appendChild(button);
            });
        }

        /**
         * 3. é¸æŠè‚¢ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç† (å¤‰æ›´ãªã—)
         */
        function handleOptionClick(event) {
            // æ—¢ã«å›ç­”æ¸ˆã¿ã§ã‚ã‚Œã°ä½•ã‚‚ã—ãªã„
            if (nextButton.style.display === 'block') return; 

            const clickedButton = event.target;
            const userGuess = clickedButton.getAttribute('data-name');

            // å…¨ã¦ã®ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
            Array.from(optionsArea.children).forEach(button => {
                button.disabled = true;
                // æ­£è§£ã®ãƒœã‚¿ãƒ³ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                if (button.getAttribute('data-name') === currentCorrectName) {
                    button.classList.add('correct');
                }
            });

            if (userGuess === currentCorrectName) {
                feedback.textContent = 'æ­£è§£ï¼ ğŸ‰';
                feedback.className = 'correct';
                clickedButton.classList.add('correct');
            } else {
                // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                feedback.textContent = `ä¸æ­£è§£... æ­£è§£ã¯ã€Œ${currentCorrectName}ã€ã§ã—ãŸã€‚`;
                feedback.className = 'incorrect';
                clickedButton.classList.add('incorrect');
            }

            // ã€Œæ¬¡ã®å•é¡Œã¸ã€ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            nextButton.style.display = 'block';
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
        nextButton.addEventListener('click', loadNewQuestion);

        // ãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', initializeGame);
    </script>
</body>
</html>